import {
  require_react_dom
} from "./chunk-U3TLXRDM.js";
import {
  require_react
} from "./chunk-ZOIWZPCO.js";
import {
  __toESM
} from "./chunk-DFKQJ226.js";

// node_modules/yet-another-react-lightbox/dist/core/consts.js
var MODULE_CAROUSEL = "carousel";
var MODULE_CONTROLLER = "controller";
var MODULE_NAVIGATION = "navigation";
var MODULE_NO_SCROLL = "no-scroll";
var MODULE_PORTAL = "portal";
var MODULE_ROOT = "root";
var MODULE_TOOLBAR = "toolbar";
var PLUGIN_COUNTER = "counter";
var PLUGIN_FULLSCREEN = "fullscreen";
var PLUGIN_THUMBNAILS = "thumbnails";
var SLIDE_STATUS_LOADING = "loading";
var SLIDE_STATUS_PLAYING = "playing";
var SLIDE_STATUS_ERROR = "error";
var SLIDE_STATUS_COMPLETE = "complete";
var SLIDE_STATUS_PLACEHOLDER = "placeholder";
var activeSlideStatus = (status) => `active-slide-${status}`;
var ACTIVE_SLIDE_LOADING = activeSlideStatus(SLIDE_STATUS_LOADING);
var ACTIVE_SLIDE_PLAYING = activeSlideStatus(SLIDE_STATUS_PLAYING);
var ACTIVE_SLIDE_ERROR = activeSlideStatus(SLIDE_STATUS_ERROR);
var ACTIVE_SLIDE_COMPLETE = activeSlideStatus(SLIDE_STATUS_COMPLETE);
var CLASS_FULLSIZE = "fullsize";
var CLASS_FLEX_CENTER = "flex_center";
var CLASS_NO_SCROLL = "no_scroll";
var CLASS_NO_SCROLL_PADDING = "no_scroll_padding";
var ACTION_PREV = "prev";
var ACTION_NEXT = "next";
var ACTION_SWIPE = "swipe";
var ACTION_CLOSE = "close";
var EVENT_ON_POINTER_DOWN = "onPointerDown";
var EVENT_ON_POINTER_MOVE = "onPointerMove";
var EVENT_ON_POINTER_UP = "onPointerUp";
var EVENT_ON_POINTER_LEAVE = "onPointerLeave";
var EVENT_ON_POINTER_CANCEL = "onPointerCancel";
var EVENT_ON_KEY_DOWN = "onKeyDown";
var EVENT_ON_KEY_UP = "onKeyUp";
var EVENT_ON_WHEEL = "onWheel";
var VK_ESCAPE = "Escape";
var VK_ARROW_LEFT = "ArrowLeft";
var VK_ARROW_RIGHT = "ArrowRight";
var ELEMENT_BUTTON = "button";
var ELEMENT_ICON = "icon";
var IMAGE_FIT_CONTAIN = "contain";
var IMAGE_FIT_COVER = "cover";
var UNKNOWN_ACTION_TYPE = "Unknown action type";

// node_modules/yet-another-react-lightbox/dist/core/utils.js
var React = __toESM(require_react(), 1);
var clsx = (...classes) => [...classes].filter((cls) => Boolean(cls)).join(" ");
var cssPrefix = "yarl__";
var cssClass = (name) => `${cssPrefix}${name}`;
var cssVar = (name) => `--${cssPrefix}${name}`;
var composePrefix = (base, prefix) => `${base}${prefix ? `_${prefix}` : ""}`;
var makeComposePrefix = (base) => (prefix) => composePrefix(base, prefix);
var label = (labels, lbl) => labels && labels[lbl] ? labels[lbl] : lbl;
var cleanup = (...cleaners) => () => {
  cleaners.forEach((cleaner) => {
    cleaner();
  });
};
var makeUseContext = (name, contextName, context) => () => {
  const ctx = React.useContext(context);
  if (!ctx) {
    throw new Error(`${name} must be used within a ${contextName}.Provider`);
  }
  return ctx;
};
var hasWindow = () => typeof window !== "undefined";
var isImageSlide = (slide) => slide.type === void 0 || slide.type === "image";
var isImageFitCover = (image, imageFit) => image.imageFit === IMAGE_FIT_COVER || image.imageFit !== IMAGE_FIT_CONTAIN && imageFit === IMAGE_FIT_COVER;
function parseLengthPercentage(input) {
  if (typeof input === "number") {
    return { pixel: input };
  }
  if (typeof input === "string") {
    const value = parseInt(input, 10);
    return input.endsWith("%") ? { percent: value } : { pixel: value };
  }
  return { pixel: 0 };
}
function computeSlideRect(containerRect, padding) {
  const paddingValue = parseLengthPercentage(padding);
  const paddingPixels = paddingValue.percent !== void 0 ? containerRect.width / 100 * paddingValue.percent : paddingValue.pixel;
  return {
    width: Math.max(containerRect.width - 2 * paddingPixels, 0),
    height: Math.max(containerRect.height - 2 * paddingPixels, 0)
  };
}
var getSlideIndex = (index, slidesCount) => slidesCount > 0 ? (index % slidesCount + slidesCount) % slidesCount : 0;
var hasSlides = (slides) => slides.length > 0;
var getSlide = (slides, index) => slides[getSlideIndex(index, slides.length)];
var getSlideIfPresent = (slides, index) => hasSlides(slides) ? getSlide(slides, index) : void 0;
function addToolbarButton(toolbar, key, button) {
  if (!button)
    return toolbar;
  const { buttons, ...restToolbar } = toolbar;
  const index = buttons.findIndex((item) => item === key);
  const buttonWithKey = React.isValidElement(button) ? React.cloneElement(button, { key }, null) : button;
  if (index >= 0) {
    const result = [...buttons];
    result.splice(index, 1, buttonWithKey);
    return { buttons: result, ...restToolbar };
  }
  return { buttons: [buttonWithKey, ...buttons], ...restToolbar };
}

// node_modules/yet-another-react-lightbox/dist/core/config.js
function createModule(name, component) {
  return { name, component };
}
function createNode(module, children) {
  return { module, children };
}
function traverseNode(node, target, apply) {
  if (node.module.name === target) {
    return apply(node);
  }
  if (node.children) {
    return [
      createNode(node.module, node.children.flatMap((n) => {
        var _a;
        return (_a = traverseNode(n, target, apply)) !== null && _a !== void 0 ? _a : [];
      }))
    ];
  }
  return [node];
}
function traverse(nodes, target, apply) {
  return nodes.flatMap((node) => {
    var _a;
    return (_a = traverseNode(node, target, apply)) !== null && _a !== void 0 ? _a : [];
  });
}
function withPlugins(root, plugins = [], augmentations = []) {
  let config = root;
  const contains = (target) => {
    const nodes = [...config];
    while (nodes.length > 0) {
      const node = nodes.pop();
      if ((node === null || node === void 0 ? void 0 : node.module.name) === target)
        return true;
      if (node === null || node === void 0 ? void 0 : node.children)
        nodes.push(...node.children);
    }
    return false;
  };
  const addParent = (target, module) => {
    if (target === "") {
      config = [createNode(module, config)];
      return;
    }
    config = traverse(config, target, (node) => [createNode(module, [node])]);
  };
  const append = (target, module) => {
    config = traverse(config, target, (node) => [createNode(node.module, [createNode(module, node.children)])]);
  };
  const addChild = (target, module, precede) => {
    config = traverse(config, target, (node) => {
      var _a;
      return [
        createNode(node.module, [
          ...precede ? [createNode(module)] : [],
          ...(_a = node.children) !== null && _a !== void 0 ? _a : [],
          ...!precede ? [createNode(module)] : []
        ])
      ];
    });
  };
  const addSibling = (target, module, precede) => {
    config = traverse(config, target, (node) => [
      ...precede ? [createNode(module)] : [],
      node,
      ...!precede ? [createNode(module)] : []
    ]);
  };
  const addModule = (module) => {
    append(MODULE_CONTROLLER, module);
  };
  const replace = (target, module) => {
    config = traverse(config, target, (node) => [createNode(module, node.children)]);
  };
  const remove = (target) => {
    config = traverse(config, target, (node) => node.children);
  };
  const augment = (augmentation) => {
    augmentations.push(augmentation);
  };
  plugins.forEach((plugin) => {
    plugin({
      contains,
      addParent,
      append,
      addChild,
      addSibling,
      addModule,
      replace,
      remove,
      augment
    });
  });
  return {
    config,
    augmentation: (props) => augmentations.reduce((acc, augmentation) => augmentation(acc), props)
  };
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useAnimation.js
var React4 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/core/hooks/useLayoutEffect.js
var React2 = __toESM(require_react(), 1);
var useLayoutEffect2 = hasWindow() ? React2.useLayoutEffect : React2.useEffect;

// node_modules/yet-another-react-lightbox/dist/core/hooks/useMotionPreference.js
var React3 = __toESM(require_react(), 1);
function useMotionPreference() {
  const [reduceMotion, setReduceMotion] = React3.useState(false);
  React3.useEffect(() => {
    var _a, _b;
    const mediaQuery = (_a = window.matchMedia) === null || _a === void 0 ? void 0 : _a.call(window, "(prefers-reduced-motion: reduce)");
    setReduceMotion(mediaQuery === null || mediaQuery === void 0 ? void 0 : mediaQuery.matches);
    const listener = (event) => setReduceMotion(event.matches);
    (_b = mediaQuery === null || mediaQuery === void 0 ? void 0 : mediaQuery.addEventListener) === null || _b === void 0 ? void 0 : _b.call(mediaQuery, "change", listener);
    return () => {
      var _a2;
      return (_a2 = mediaQuery === null || mediaQuery === void 0 ? void 0 : mediaQuery.removeEventListener) === null || _a2 === void 0 ? void 0 : _a2.call(mediaQuery, "change", listener);
    };
  }, []);
  return reduceMotion;
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useAnimation.js
function currentTransformation(node) {
  let x = 0;
  let y = 0;
  let z = 0;
  const matrix = window.getComputedStyle(node).transform;
  const matcher = matrix.match(/matrix.*\((.+)\)/);
  if (matcher) {
    const values = matcher[1].split(",").map((str) => Number.parseInt(str, 10));
    if (values.length === 6) {
      x = values[4];
      y = values[5];
    } else if (values.length === 16) {
      x = values[12];
      y = values[13];
      z = values[14];
    }
  }
  return { x, y, z };
}
function useAnimation(nodeRef, computeAnimation) {
  const snapshot = React4.useRef();
  const animation = React4.useRef();
  const reduceMotion = useMotionPreference();
  useLayoutEffect2(() => {
    var _a, _b, _c;
    if (nodeRef.current && snapshot.current !== void 0 && !reduceMotion) {
      const { keyframes, duration, easing, onfinish } = computeAnimation(snapshot.current, nodeRef.current.getBoundingClientRect(), currentTransformation(nodeRef.current)) || {};
      if (keyframes && duration) {
        (_a = animation.current) === null || _a === void 0 ? void 0 : _a.cancel();
        animation.current = void 0;
        try {
          animation.current = (_c = (_b = nodeRef.current).animate) === null || _c === void 0 ? void 0 : _c.call(_b, keyframes, { duration, easing });
        } catch (err) {
          console.error(err);
        }
        if (animation.current) {
          animation.current.onfinish = () => {
            animation.current = void 0;
            onfinish === null || onfinish === void 0 ? void 0 : onfinish();
          };
        }
      }
    }
    snapshot.current = void 0;
  });
  return {
    prepareAnimation: (currentSnapshot) => {
      snapshot.current = currentSnapshot;
    },
    isAnimationPlaying: () => {
      var _a;
      return ((_a = animation.current) === null || _a === void 0 ? void 0 : _a.playState) === "running";
    }
  };
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useContainerRect.js
var React5 = __toESM(require_react(), 1);
function useContainerRect() {
  const [containerRect, setContainerRect] = React5.useState();
  const containerRef = React5.useRef(null);
  const observerRef = React5.useRef();
  const setContainerRef = React5.useCallback((node) => {
    containerRef.current = node;
    if (observerRef.current) {
      observerRef.current.disconnect();
      observerRef.current = void 0;
    }
    const updateContainerRect = () => {
      if (node) {
        const styles = window.getComputedStyle(node);
        const parse = (value) => parseFloat(value) || 0;
        setContainerRect({
          width: Math.round(node.clientWidth - parse(styles.paddingLeft) - parse(styles.paddingRight)),
          height: Math.round(node.clientHeight - parse(styles.paddingTop) - parse(styles.paddingBottom))
        });
      } else {
        setContainerRect(void 0);
      }
    };
    updateContainerRect();
    if (node && typeof ResizeObserver !== "undefined") {
      observerRef.current = new ResizeObserver(updateContainerRect);
      observerRef.current.observe(node);
    }
  }, []);
  return React5.useMemo(() => ({
    setContainerRef,
    containerRef,
    containerRect
  }), [setContainerRef, containerRef, containerRect]);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useDelay.js
var React7 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/core/contexts/Timeouts.js
var React6 = __toESM(require_react(), 1);
var TimeoutsContext = React6.createContext(null);
var useTimeouts = makeUseContext("useTimeouts", "TimeoutsContext", TimeoutsContext);
function TimeoutsProvider({ children }) {
  const [timeouts] = React6.useState([]);
  React6.useEffect(() => () => {
    timeouts.forEach((tid) => window.clearTimeout(tid));
    timeouts.splice(0, timeouts.length);
  }, [timeouts]);
  const context = React6.useMemo(() => {
    const removeTimeout = (id) => {
      timeouts.splice(0, timeouts.length, ...timeouts.filter((tid) => tid !== id));
    };
    const setTimeout = (fn, delay) => {
      const id = window.setTimeout(() => {
        removeTimeout(id);
        fn();
      }, delay);
      timeouts.push(id);
      return id;
    };
    const clearTimeout = (id) => {
      if (id !== void 0) {
        removeTimeout(id);
        window.clearTimeout(id);
      }
    };
    return { setTimeout, clearTimeout };
  }, [timeouts]);
  return React6.createElement(TimeoutsContext.Provider, { value: context }, children);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useDelay.js
function useDelay() {
  const timeoutId = React7.useRef();
  const { setTimeout, clearTimeout } = useTimeouts();
  return React7.useCallback((callback, delay) => {
    clearTimeout(timeoutId.current);
    timeoutId.current = setTimeout(callback, delay > 0 ? delay : 0);
  }, [setTimeout, clearTimeout]);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useEventCallback.js
var React8 = __toESM(require_react(), 1);
function useEventCallback(fn) {
  const ref = React8.useRef(fn);
  useLayoutEffect2(() => {
    ref.current = fn;
  });
  return React8.useCallback((...args) => {
    var _a;
    return (_a = ref.current) === null || _a === void 0 ? void 0 : _a.call(ref, ...args);
  }, []);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useForkRef.js
var React9 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
function useForkRef(refA, refB) {
  return React9.useMemo(() => refA == null && refB == null ? null : (refValue) => {
    setRef(refA, refValue);
    setRef(refB, refValue);
  }, [refA, refB]);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useLoseFocus.js
var React17 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/core/modules/Controller.js
var React16 = __toESM(require_react(), 1);

// node_modules/yet-another-react-lightbox/dist/core/contexts/Events.js
var React10 = __toESM(require_react(), 1);
var EventsContext = React10.createContext(null);
var useEvents = makeUseContext("useEvents", "EventsContext", EventsContext);
function EventsProvider({ children }) {
  const [subscriptions] = React10.useState({});
  React10.useEffect(() => () => {
    Object.keys(subscriptions).forEach((topic) => delete subscriptions[topic]);
  }, [subscriptions]);
  const context = React10.useMemo(() => {
    const unsubscribe = (topic, callback) => {
      var _a;
      (_a = subscriptions[topic]) === null || _a === void 0 ? void 0 : _a.splice(0, subscriptions[topic].length, ...subscriptions[topic].filter((cb) => cb !== callback));
    };
    const subscribe = (topic, callback) => {
      if (!subscriptions[topic]) {
        subscriptions[topic] = [];
      }
      subscriptions[topic].push(callback);
      return () => unsubscribe(topic, callback);
    };
    const publish = (...[topic, event]) => {
      var _a;
      (_a = subscriptions[topic]) === null || _a === void 0 ? void 0 : _a.forEach((callback) => callback(event));
    };
    return { publish, subscribe, unsubscribe };
  }, [subscriptions]);
  return React10.createElement(EventsContext.Provider, { value: context }, children);
}

// node_modules/yet-another-react-lightbox/dist/core/contexts/LightboxProps.js
var React11 = __toESM(require_react(), 1);
var LightboxPropsContext = React11.createContext(null);
var useLightboxProps = makeUseContext("useLightboxProps", "LightboxPropsContext", LightboxPropsContext);
function LightboxPropsProvider({ children, ...props }) {
  return React11.createElement(LightboxPropsContext.Provider, { value: props }, children);
}

// node_modules/yet-another-react-lightbox/dist/core/contexts/LightboxState.js
var React12 = __toESM(require_react(), 1);
var LightboxStateContext = React12.createContext(null);
var useLightboxState = makeUseContext("useLightboxState", "LightboxStateContext", LightboxStateContext);
var LightboxDispatchContext = React12.createContext(null);
var useLightboxDispatch = makeUseContext("useLightboxDispatch", "LightboxDispatchContext", LightboxDispatchContext);
function reducer(state, action) {
  switch (action.type) {
    case "swipe": {
      const { slides } = state;
      const increment = (action === null || action === void 0 ? void 0 : action.increment) || 0;
      const globalIndex = state.globalIndex + increment;
      const currentIndex = getSlideIndex(globalIndex, slides.length);
      const currentSlide = getSlideIfPresent(slides, currentIndex);
      const animation = increment || action.duration ? {
        increment,
        duration: action.duration,
        easing: action.easing
      } : void 0;
      return { slides, currentIndex, globalIndex, currentSlide, animation };
    }
    case "update":
      return {
        slides: action.slides,
        currentIndex: action.index,
        globalIndex: action.index,
        currentSlide: getSlideIfPresent(action.slides, action.index)
      };
    default:
      throw new Error(UNKNOWN_ACTION_TYPE);
  }
}
function LightboxStateProvider({ slides, index, children }) {
  const [state, dispatch] = React12.useReducer(reducer, {
    slides,
    currentIndex: index,
    globalIndex: index,
    currentSlide: getSlideIfPresent(slides, index)
  });
  React12.useEffect(() => {
    dispatch({ type: "update", slides, index });
  }, [slides, index]);
  const context = React12.useMemo(() => ({ ...state, state, dispatch }), [state, dispatch]);
  return React12.createElement(
    LightboxDispatchContext.Provider,
    { value: dispatch },
    React12.createElement(LightboxStateContext.Provider, { value: context }, children)
  );
}

// node_modules/yet-another-react-lightbox/dist/core/modules/controller/usePointerSwipe.js
var React13 = __toESM(require_react(), 1);
function usePointerSwipe(subscribeSensors, isSwipeValid, containerWidth, swipeAnimationDuration, onSwipeStart, onSwipeProgress, onSwipeFinish, onSwipeCancel) {
  const offset = React13.useRef(0);
  const pointers = React13.useRef([]);
  const activePointer = React13.useRef();
  const startTime = React13.useRef(0);
  const clearPointer = React13.useCallback((event) => {
    if (activePointer.current === event.pointerId) {
      activePointer.current = void 0;
    }
    const currentPointers = pointers.current;
    currentPointers.splice(0, currentPointers.length, ...currentPointers.filter((p) => p.pointerId !== event.pointerId));
  }, []);
  const addPointer = React13.useCallback((event) => {
    clearPointer(event);
    event.persist();
    pointers.current.push(event);
  }, [clearPointer]);
  const onPointerDown = useEventCallback((event) => {
    addPointer(event);
  });
  const onPointerUp = useEventCallback((event) => {
    if (pointers.current.find((x) => x.pointerId === event.pointerId) && activePointer.current === event.pointerId) {
      const duration = Date.now() - startTime.current;
      const currentOffset = offset.current;
      if (Math.abs(currentOffset) > 0.3 * containerWidth || Math.abs(currentOffset) > 5 && duration < swipeAnimationDuration) {
        onSwipeFinish(currentOffset, duration);
      } else {
        onSwipeCancel(currentOffset);
      }
      offset.current = 0;
    }
    clearPointer(event);
  });
  const onPointerMove = useEventCallback((event) => {
    const pointer = pointers.current.find((p) => p.pointerId === event.pointerId);
    if (pointer) {
      const isCurrentPointer = activePointer.current === event.pointerId;
      if (event.buttons === 0) {
        if (isCurrentPointer && offset.current !== 0) {
          onPointerUp(event);
        } else {
          clearPointer(pointer);
        }
        return;
      }
      const deltaX = event.clientX - pointer.clientX;
      const deltaY = event.clientY - pointer.clientY;
      if (activePointer.current === void 0 && isSwipeValid(deltaX) && Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
        addPointer(event);
        activePointer.current = event.pointerId;
        startTime.current = Date.now();
        onSwipeStart();
      } else if (isCurrentPointer) {
        offset.current = deltaX;
        onSwipeProgress(deltaX);
      }
    }
  });
  React13.useEffect(() => cleanup(subscribeSensors(EVENT_ON_POINTER_DOWN, onPointerDown), subscribeSensors(EVENT_ON_POINTER_MOVE, onPointerMove), subscribeSensors(EVENT_ON_POINTER_UP, onPointerUp), subscribeSensors(EVENT_ON_POINTER_LEAVE, onPointerUp), subscribeSensors(EVENT_ON_POINTER_CANCEL, onPointerUp)), [subscribeSensors, onPointerDown, onPointerMove, onPointerUp]);
}

// node_modules/yet-another-react-lightbox/dist/core/modules/controller/usePreventSwipeNavigation.js
var React14 = __toESM(require_react(), 1);
var WHEEL = "wheel";
function preventDefault(event) {
  if (Math.abs(event.deltaX) > Math.abs(event.deltaY) || event.ctrlKey) {
    event.preventDefault();
  }
}
function usePreventSwipeNavigation() {
  const ref = React14.useRef(null);
  return React14.useCallback((node) => {
    var _a;
    if (node) {
      node.addEventListener(WHEEL, preventDefault, { passive: false });
    } else {
      (_a = ref.current) === null || _a === void 0 ? void 0 : _a.removeEventListener(WHEEL, preventDefault);
    }
    ref.current = node;
  }, []);
}

// node_modules/yet-another-react-lightbox/dist/core/modules/controller/useWheelSwipe.js
var React15 = __toESM(require_react(), 1);
function useWheelSwipe(swipeState, subscribeSensors, isSwipeValid, containerWidth, swipeAnimationDuration, onSwipeStart, onSwipeProgress, onSwipeFinish, onSwipeCancel) {
  const offset = React15.useRef(0);
  const intent = React15.useRef(0);
  const intentCleanup = React15.useRef();
  const resetCleanup = React15.useRef();
  const wheelResidualMomentum = React15.useRef(0);
  const startTime = React15.useRef(0);
  const { setTimeout, clearTimeout } = useTimeouts();
  const cancelSwipeIntentCleanup = React15.useCallback(() => {
    if (intentCleanup.current) {
      clearTimeout(intentCleanup.current);
      intentCleanup.current = void 0;
    }
  }, [clearTimeout]);
  const cancelSwipeResetCleanup = React15.useCallback(() => {
    if (resetCleanup.current) {
      clearTimeout(resetCleanup.current);
      resetCleanup.current = void 0;
    }
  }, [clearTimeout]);
  const handleCleanup = useEventCallback(() => {
    if (swipeState !== SwipeState.SWIPE) {
      offset.current = 0;
      startTime.current = 0;
      cancelSwipeIntentCleanup();
      cancelSwipeResetCleanup();
    }
  });
  React15.useEffect(handleCleanup, [swipeState, handleCleanup]);
  const handleCancelSwipe = useEventCallback((currentSwipeOffset) => {
    resetCleanup.current = void 0;
    if (offset.current === currentSwipeOffset) {
      onSwipeCancel(offset.current);
    }
  });
  const onWheel = useEventCallback((event) => {
    if (event.ctrlKey) {
      return;
    }
    if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {
      return;
    }
    if (!swipeState) {
      if (Math.abs(event.deltaX) <= 1.2 * Math.abs(wheelResidualMomentum.current)) {
        wheelResidualMomentum.current = event.deltaX;
        return;
      }
      if (!isSwipeValid(-event.deltaX)) {
        return;
      }
      intent.current += event.deltaX;
      cancelSwipeIntentCleanup();
      if (Math.abs(intent.current) > 30) {
        intent.current = 0;
        wheelResidualMomentum.current = 0;
        startTime.current = Date.now();
        onSwipeStart();
      } else {
        const currentSwipeIntent = intent.current;
        intentCleanup.current = setTimeout(() => {
          intentCleanup.current = void 0;
          if (currentSwipeIntent === intent.current) {
            intent.current = 0;
          }
        }, swipeAnimationDuration);
      }
    } else if (swipeState === SwipeState.SWIPE) {
      let newSwipeOffset = offset.current - event.deltaX;
      newSwipeOffset = Math.min(Math.abs(newSwipeOffset), containerWidth) * Math.sign(newSwipeOffset);
      offset.current = newSwipeOffset;
      onSwipeProgress(newSwipeOffset);
      cancelSwipeResetCleanup();
      if (Math.abs(newSwipeOffset) > 0.2 * containerWidth) {
        wheelResidualMomentum.current = event.deltaX;
        onSwipeFinish(newSwipeOffset, Date.now() - startTime.current);
        return;
      }
      resetCleanup.current = setTimeout(() => handleCancelSwipe(newSwipeOffset), 2 * swipeAnimationDuration);
    } else {
      wheelResidualMomentum.current = event.deltaX;
    }
  });
  React15.useEffect(() => subscribeSensors(EVENT_ON_WHEEL, onWheel), [subscribeSensors, onWheel]);
}

// node_modules/yet-another-react-lightbox/dist/core/modules/controller/index.js
var SwipeState;
(function(SwipeState2) {
  SwipeState2[SwipeState2["NONE"] = 0] = "NONE";
  SwipeState2[SwipeState2["SWIPE"] = 1] = "SWIPE";
  SwipeState2[SwipeState2["ANIMATION"] = 2] = "ANIMATION";
})(SwipeState || (SwipeState = {}));

// node_modules/yet-another-react-lightbox/dist/core/modules/Controller.js
var cssContainerPrefix = makeComposePrefix("container");
var ControllerContext = React16.createContext(null);
var useController = makeUseContext("useController", "ControllerContext", ControllerContext);
function Controller({ children, ...props }) {
  var _a;
  const { carousel, animation, controller, on, styles, render } = props;
  const [toolbarWidth, setToolbarWidth] = React16.useState();
  const state = useLightboxState();
  const dispatch = useLightboxDispatch();
  const [swipeState, setSwipeState] = React16.useState(SwipeState.NONE);
  const swipeOffset = React16.useRef(0);
  const { registerSensors, subscribeSensors } = useSensors();
  const { subscribe, publish } = useEvents();
  const cleanupAnimationIncrement = useDelay();
  const cleanupSwipeOffset = useDelay();
  const { containerRef, setContainerRef, containerRect } = useContainerRect();
  const handleContainerRef = useForkRef(usePreventSwipeNavigation(), setContainerRef);
  const carouselRef = React16.useRef(null);
  const setCarouselRef = useForkRef(carouselRef, void 0);
  const isRTL = useRTL();
  const rtl = (value) => (isRTL ? -1 : 1) * (typeof value === "number" ? value : 1);
  const focus = useEventCallback(() => {
    var _a2;
    return (_a2 = containerRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
  });
  const getLightboxProps = useEventCallback(() => props);
  const getLightboxState = useEventCallback(() => state);
  const prev = React16.useCallback((params) => publish(ACTION_PREV, params), [publish]);
  const next = React16.useCallback((params) => publish(ACTION_NEXT, params), [publish]);
  const close = React16.useCallback(() => publish(ACTION_CLOSE), [publish]);
  const isSwipeValid = (offset) => !(carousel.finite && (rtl(offset) > 0 && state.currentIndex === 0 || rtl(offset) < 0 && state.currentIndex === state.slides.length - 1));
  const setSwipeOffset = (offset) => {
    var _a2;
    swipeOffset.current = offset;
    (_a2 = containerRef.current) === null || _a2 === void 0 ? void 0 : _a2.style.setProperty(cssVar("swipe_offset"), `${Math.round(offset)}px`);
  };
  const { prepareAnimation, isAnimationPlaying } = useAnimation(carouselRef, (snapshot, rect, translate) => {
    var _a2;
    if (carouselRef.current && containerRect && ((_a2 = state.animation) === null || _a2 === void 0 ? void 0 : _a2.duration)) {
      const parsedSpacing = parseLengthPercentage(carousel.spacing);
      const spacingValue = (parsedSpacing.percent ? parsedSpacing.percent * containerRect.width / 100 : parsedSpacing.pixel) || 0;
      return {
        keyframes: [
          {
            transform: `translateX(${rtl(state.globalIndex - snapshot.index) * (containerRect.width + spacingValue) + snapshot.rect.x - rect.x + translate.x}px)`
          },
          { transform: "translateX(0)" }
        ],
        duration: state.animation.duration,
        easing: state.animation.easing
      };
    }
    return void 0;
  });
  const swipe = useEventCallback((action) => {
    var _a2, _b;
    const currentSwipeOffset = action.offset || 0;
    const swipeDuration = !currentSwipeOffset ? (_a2 = animation.navigation) !== null && _a2 !== void 0 ? _a2 : animation.swipe : animation.swipe;
    const swipeEasing = !currentSwipeOffset && !isAnimationPlaying() ? animation.easing.navigation : animation.easing.swipe;
    let { direction } = action;
    const count = (_b = action.count) !== null && _b !== void 0 ? _b : 1;
    let newSwipeState = SwipeState.ANIMATION;
    let newSwipeAnimationDuration = swipeDuration * count;
    if (!direction) {
      const containerWidth = containerRect === null || containerRect === void 0 ? void 0 : containerRect.width;
      const elapsedTime = action.duration || 0;
      const expectedTime = containerWidth ? swipeDuration / containerWidth * Math.abs(currentSwipeOffset) : swipeDuration;
      if (count !== 0) {
        if (elapsedTime < expectedTime) {
          newSwipeAnimationDuration = newSwipeAnimationDuration / expectedTime * Math.max(elapsedTime, expectedTime / 5);
        } else if (containerWidth) {
          newSwipeAnimationDuration = swipeDuration / containerWidth * (containerWidth - Math.abs(currentSwipeOffset));
        }
        direction = rtl(currentSwipeOffset) > 0 ? ACTION_PREV : ACTION_NEXT;
      } else {
        newSwipeAnimationDuration = swipeDuration / 2;
      }
    }
    let increment = 0;
    if (direction === ACTION_PREV) {
      if (isSwipeValid(rtl(1))) {
        increment = -count;
      } else {
        newSwipeState = SwipeState.NONE;
        newSwipeAnimationDuration = swipeDuration;
      }
    } else if (direction === ACTION_NEXT) {
      if (isSwipeValid(rtl(-1))) {
        increment = count;
      } else {
        newSwipeState = SwipeState.NONE;
        newSwipeAnimationDuration = swipeDuration;
      }
    }
    newSwipeAnimationDuration = Math.round(newSwipeAnimationDuration);
    cleanupSwipeOffset(() => {
      setSwipeOffset(0);
      setSwipeState(SwipeState.NONE);
    }, newSwipeAnimationDuration);
    if (carouselRef.current) {
      prepareAnimation({
        rect: carouselRef.current.getBoundingClientRect(),
        index: state.globalIndex
      });
    }
    setSwipeState(newSwipeState);
    publish(ACTION_SWIPE, {
      type: "swipe",
      increment,
      duration: newSwipeAnimationDuration,
      easing: swipeEasing
    });
  });
  React16.useEffect(() => {
    var _a2, _b;
    if (((_a2 = state.animation) === null || _a2 === void 0 ? void 0 : _a2.increment) && ((_b = state.animation) === null || _b === void 0 ? void 0 : _b.duration)) {
      cleanupAnimationIncrement(() => dispatch({ type: "swipe", increment: 0 }), state.animation.duration);
    }
  }, [state.animation, dispatch, cleanupAnimationIncrement]);
  const swipeParams = [
    subscribeSensors,
    isSwipeValid,
    (containerRect === null || containerRect === void 0 ? void 0 : containerRect.width) || 0,
    animation.swipe,
    () => setSwipeState(SwipeState.SWIPE),
    (offset) => setSwipeOffset(offset),
    (offset, duration) => swipe({ offset, duration, count: 1 }),
    (offset) => swipe({ offset, count: 0 })
  ];
  usePointerSwipe(...swipeParams);
  useWheelSwipe(swipeState, ...swipeParams);
  const focusOnMount = useEventCallback(() => {
    var _a2;
    if (controller.focus) {
      (_a2 = containerRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    }
  });
  React16.useEffect(focusOnMount, [focusOnMount]);
  const onViewCallback = useEventCallback(() => {
    var _a2;
    (_a2 = on.view) === null || _a2 === void 0 ? void 0 : _a2.call(on, { index: state.currentIndex });
  });
  React16.useEffect(onViewCallback, [state.globalIndex, onViewCallback]);
  React16.useEffect(() => cleanup(subscribe(ACTION_PREV, (action) => swipe({ direction: ACTION_PREV, ...action })), subscribe(ACTION_NEXT, (action) => swipe({ direction: ACTION_NEXT, ...action })), subscribe(ACTION_SWIPE, (action) => dispatch(action))), [subscribe, swipe, dispatch]);
  React16.useEffect(() => subscribeSensors(EVENT_ON_KEY_UP, (event) => {
    if (event.code === VK_ESCAPE) {
      close();
    }
  }), [subscribeSensors, close]);
  const context = React16.useMemo(() => ({
    prev,
    next,
    close,
    focus,
    slideRect: containerRect ? computeSlideRect(containerRect, carousel.padding) : { width: 0, height: 0 },
    containerRect: containerRect || { width: 0, height: 0 },
    subscribeSensors,
    containerRef,
    setCarouselRef,
    toolbarWidth,
    setToolbarWidth
  }), [
    prev,
    next,
    close,
    focus,
    subscribeSensors,
    containerRect,
    containerRef,
    setCarouselRef,
    toolbarWidth,
    setToolbarWidth,
    carousel.padding
  ]);
  React16.useImperativeHandle(controller.ref, () => ({
    prev,
    next,
    close,
    focus,
    getLightboxProps,
    getLightboxState
  }), [prev, next, close, focus, getLightboxProps, getLightboxState]);
  return React16.createElement("div", { ref: handleContainerRef, className: clsx(cssClass(cssContainerPrefix()), cssClass(CLASS_FLEX_CENTER)), style: {
    ...swipeState === SwipeState.SWIPE ? { [cssVar("swipe_offset")]: `${Math.round(swipeOffset.current)}px` } : null,
    ...controller.touchAction !== "none" ? { [cssVar("controller_touch_action")]: controller.touchAction } : null,
    ...styles.container
  }, ...controller.aria ? { role: "presentation", "aria-live": "polite" } : null, tabIndex: -1, ...registerSensors }, containerRect && React16.createElement(
    ControllerContext.Provider,
    { value: context },
    children,
    (_a = render.controls) === null || _a === void 0 ? void 0 : _a.call(render)
  ));
}
var ControllerModule = createModule(MODULE_CONTROLLER, Controller);

// node_modules/yet-another-react-lightbox/dist/core/hooks/useLoseFocus.js
function useLoseFocus(disabled = false) {
  const focused = React17.useRef(disabled);
  const { focus } = useController();
  useLayoutEffect2(() => {
    if (disabled) {
      focus();
    }
  }, [disabled, focus]);
  const onFocus = React17.useCallback(() => {
    focused.current = true;
  }, []);
  const onBlur = React17.useCallback(() => {
    focused.current = false;
  }, []);
  return { onFocus, onBlur };
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useRTL.js
var React18 = __toESM(require_react(), 1);
function useRTL() {
  const [isRTL, setIsRTL] = React18.useState(false);
  useLayoutEffect2(() => {
    setIsRTL(window.getComputedStyle(window.document.documentElement).direction === "rtl");
  }, []);
  return isRTL;
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useSensors.js
var React19 = __toESM(require_react(), 1);
function useSensors() {
  const [subscribers] = React19.useState({});
  return React19.useMemo(() => {
    const notifySubscribers = (type, event) => {
      var _a;
      (_a = subscribers[type]) === null || _a === void 0 ? void 0 : _a.forEach((listener) => {
        if (!event.isPropagationStopped())
          listener(event);
      });
    };
    return {
      registerSensors: {
        onPointerDown: (event) => notifySubscribers(EVENT_ON_POINTER_DOWN, event),
        onPointerMove: (event) => notifySubscribers(EVENT_ON_POINTER_MOVE, event),
        onPointerUp: (event) => notifySubscribers(EVENT_ON_POINTER_UP, event),
        onPointerLeave: (event) => notifySubscribers(EVENT_ON_POINTER_LEAVE, event),
        onPointerCancel: (event) => notifySubscribers(EVENT_ON_POINTER_CANCEL, event),
        onKeyDown: (event) => notifySubscribers(EVENT_ON_KEY_DOWN, event),
        onKeyUp: (event) => notifySubscribers(EVENT_ON_KEY_UP, event),
        onWheel: (event) => notifySubscribers(EVENT_ON_WHEEL, event)
      },
      subscribeSensors: (type, callback) => {
        if (!subscribers[type]) {
          subscribers[type] = [];
        }
        subscribers[type].unshift(callback);
        return () => {
          const listeners = subscribers[type];
          if (listeners) {
            listeners.splice(0, listeners.length, ...listeners.filter((el) => el !== callback));
          }
        };
      }
    };
  }, [subscribers]);
}

// node_modules/yet-another-react-lightbox/dist/core/hooks/useThrottle.js
var React20 = __toESM(require_react(), 1);
function useThrottle(callback, delay) {
  const lastCallbackTime = React20.useRef(0);
  const delayCallback = useDelay();
  const executeCallback = useEventCallback((...args) => {
    lastCallbackTime.current = Date.now();
    callback(args);
  });
  return React20.useCallback((...args) => {
    delayCallback(() => {
      executeCallback(args);
    }, delay - (Date.now() - lastCallbackTime.current));
  }, [delay, executeCallback, delayCallback]);
}

// node_modules/yet-another-react-lightbox/dist/core/components/IconButton.js
var React21 = __toESM(require_react(), 1);
var IconButton = React21.forwardRef(function IconButton2({ label: label2, className, icon: Icon, renderIcon, onClick, style, ...rest }, ref) {
  const { styles, labels } = useLightboxProps();
  return React21.createElement("button", { ref, type: "button", "aria-label": label(labels, label2), className: clsx(cssClass(ELEMENT_BUTTON), className), onClick, style: { ...style, ...styles.button }, ...rest }, renderIcon ? renderIcon() : React21.createElement(Icon, { className: cssClass(ELEMENT_ICON), style: styles.icon }));
});

// node_modules/yet-another-react-lightbox/dist/core/components/Icons.js
var React22 = __toESM(require_react(), 1);
function svgIcon(name, children) {
  const icon = (props) => React22.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24", "aria-hidden": "true", focusable: "false", ...props }, children);
  icon.displayName = name;
  return icon;
}
function createIcon(name, glyph) {
  return svgIcon(name, React22.createElement(
    "g",
    { fill: "currentColor" },
    React22.createElement("path", { d: "M0 0h24v24H0z", fill: "none" }),
    glyph
  ));
}
var CloseIcon = createIcon("Close", React22.createElement("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }));
var PreviousIcon = createIcon("Previous", React22.createElement("path", { d: "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" }));
var NextIcon = createIcon("Next", React22.createElement("path", { d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" }));
var LoadingIcon = createIcon("Loading", React22.createElement(React22.Fragment, null, Array.from({ length: 8 }).map((_, index, array) => React22.createElement("line", { key: index, x1: "12", y1: "6.5", x2: "12", y2: "1.8", strokeLinecap: "round", strokeWidth: "2.6", stroke: "currentColor", strokeOpacity: 1 / array.length * (index + 1), transform: `rotate(${360 / array.length * index}, 12, 12)` }))));
var ErrorIcon = createIcon("Error", React22.createElement("path", { d: "M21.9,21.9l-8.49-8.49l0,0L3.59,3.59l0,0L2.1,2.1L0.69,3.51L3,5.83V19c0,1.1,0.9,2,2,2h13.17l2.31,2.31L21.9,21.9z M5,18 l3.5-4.5l2.5,3.01L12.17,15l3,3H5z M21,18.17L5.83,3H19c1.1,0,2,0.9,2,2V18.17z" }));

// node_modules/yet-another-react-lightbox/dist/core/components/ImageSlide.js
var React23 = __toESM(require_react(), 1);
var slidePrefix = makeComposePrefix("slide");
var slideImagePrefix = makeComposePrefix("slide_image");
function ImageSlide({ slide: image, offset, render, rect, imageFit, onClick, onLoad, style }) {
  var _a, _b, _c, _d, _e, _f, _g;
  const [status, setStatus] = React23.useState(SLIDE_STATUS_LOADING);
  const { publish } = useEvents();
  const { setTimeout } = useTimeouts();
  const imageRef = React23.useRef(null);
  React23.useEffect(() => {
    if (offset === 0) {
      publish(activeSlideStatus(status));
    }
  }, [offset, status, publish]);
  const handleLoading = useEventCallback((img) => {
    ("decode" in img ? img.decode() : Promise.resolve()).catch(() => {
    }).then(() => {
      if (!img.parentNode) {
        return;
      }
      setStatus(SLIDE_STATUS_COMPLETE);
      setTimeout(() => {
        onLoad === null || onLoad === void 0 ? void 0 : onLoad(img);
      }, 0);
    });
  });
  const setImageRef = React23.useCallback((img) => {
    imageRef.current = img;
    if (img === null || img === void 0 ? void 0 : img.complete) {
      handleLoading(img);
    }
  }, [handleLoading]);
  const handleOnLoad = React23.useCallback((event) => {
    handleLoading(event.currentTarget);
  }, [handleLoading]);
  const onError = React23.useCallback(() => {
    setStatus(SLIDE_STATUS_ERROR);
  }, []);
  const cover = isImageFitCover(image, imageFit);
  const nonInfinite = (value, fallback) => Number.isFinite(value) ? value : fallback;
  const maxWidth = nonInfinite(Math.max(...((_b = (_a = image.srcSet) === null || _a === void 0 ? void 0 : _a.map((x) => x.width)) !== null && _b !== void 0 ? _b : []).concat(image.width ? [image.width] : [])), ((_c = imageRef.current) === null || _c === void 0 ? void 0 : _c.naturalWidth) || 0);
  const maxHeight = nonInfinite(Math.max(...((_e = (_d = image.srcSet) === null || _d === void 0 ? void 0 : _d.map((x) => x.height)) !== null && _e !== void 0 ? _e : []).concat(image.height ? [image.height] : [])), ((_f = imageRef.current) === null || _f === void 0 ? void 0 : _f.naturalHeight) || 0);
  const defaultStyle = maxWidth && maxHeight ? {
    maxWidth: `min(${maxWidth}px, 100%)`,
    maxHeight: `min(${maxHeight}px, 100%)`
  } : {
    maxWidth: "100%",
    maxHeight: "100%"
  };
  const srcSet = (_g = image.srcSet) === null || _g === void 0 ? void 0 : _g.sort((a, b) => a.width - b.width).map((item) => `${item.src} ${item.width}w`).join(", ");
  const estimateActualWidth = () => rect && !cover && image.width && image.height ? rect.height / image.height * image.width : Number.MAX_VALUE;
  const sizes = srcSet && rect && hasWindow() ? `${Math.round(Math.min(estimateActualWidth(), rect.width))}px` : void 0;
  return React23.createElement(
    React23.Fragment,
    null,
    React23.createElement("img", { ref: setImageRef, onLoad: handleOnLoad, onError, onClick, className: clsx(cssClass(slideImagePrefix()), cover && cssClass(slideImagePrefix("cover")), status !== SLIDE_STATUS_COMPLETE && cssClass(slideImagePrefix("loading"))), draggable: false, alt: image.alt, style: { ...defaultStyle, ...style }, sizes, srcSet, src: image.src }),
    status !== SLIDE_STATUS_COMPLETE && React23.createElement(
      "div",
      { className: cssClass(slidePrefix(SLIDE_STATUS_PLACEHOLDER)) },
      status === SLIDE_STATUS_LOADING && ((render === null || render === void 0 ? void 0 : render.iconLoading) ? render.iconLoading() : React23.createElement(LoadingIcon, { className: clsx(cssClass(ELEMENT_ICON), cssClass(slidePrefix(SLIDE_STATUS_LOADING))) })),
      status === SLIDE_STATUS_ERROR && ((render === null || render === void 0 ? void 0 : render.iconError) ? render.iconError() : React23.createElement(ErrorIcon, { className: clsx(cssClass(ELEMENT_ICON), cssClass(slidePrefix(SLIDE_STATUS_ERROR))) }))
    )
  );
}

// node_modules/yet-another-react-lightbox/dist/core/modules/Carousel.js
var React24 = __toESM(require_react(), 1);
function cssPrefix2(value) {
  return composePrefix(MODULE_CAROUSEL, value);
}
function cssSlidePrefix(value) {
  return composePrefix("slide", value);
}
function CarouselSlide({ slide, offset }) {
  const containerRef = React24.useRef(null);
  const { currentIndex } = useLightboxState();
  const { slideRect, close } = useController();
  const { render, carousel: { imageFit }, on: { click: onClick }, controller: { closeOnBackdropClick } } = useLightboxProps();
  const renderSlide = () => {
    var _a, _b, _c, _d;
    let rendered = (_a = render.slide) === null || _a === void 0 ? void 0 : _a.call(render, { slide, offset, rect: slideRect });
    if (!rendered && isImageSlide(slide)) {
      rendered = React24.createElement(ImageSlide, { slide, offset, render, rect: slideRect, imageFit, onClick: offset === 0 ? () => onClick === null || onClick === void 0 ? void 0 : onClick({ index: currentIndex }) : void 0 });
    }
    return rendered ? React24.createElement(
      React24.Fragment,
      null,
      (_b = render.slideHeader) === null || _b === void 0 ? void 0 : _b.call(render, { slide }),
      ((_c = render.slideContainer) !== null && _c !== void 0 ? _c : ({ children }) => children)({ slide, children: rendered }),
      (_d = render.slideFooter) === null || _d === void 0 ? void 0 : _d.call(render, { slide })
    ) : null;
  };
  const handleBackdropClick = (event) => {
    const container = containerRef.current;
    const target = event.target instanceof HTMLElement ? event.target : void 0;
    if (closeOnBackdropClick && target && container && (target === container || Array.from(container.children).find((x) => x === target) && target.classList.contains(cssClass(CLASS_FULLSIZE)))) {
      close();
    }
  };
  return React24.createElement("div", { ref: containerRef, className: clsx(cssClass(cssSlidePrefix()), offset === 0 && cssClass(cssSlidePrefix("current")), cssClass(CLASS_FLEX_CENTER)), onClick: handleBackdropClick }, renderSlide());
}
function Placeholder() {
  return React24.createElement("div", { className: cssClass("slide") });
}
function Carousel({ carousel: { finite, preload, padding, spacing } }) {
  const { slides, currentIndex, globalIndex } = useLightboxState();
  const { setCarouselRef } = useController();
  const spacingValue = parseLengthPercentage(spacing);
  const paddingValue = parseLengthPercentage(padding);
  const items = [];
  if ((slides === null || slides === void 0 ? void 0 : slides.length) > 0) {
    for (let i = currentIndex - preload; i < currentIndex; i += 1) {
      const key = globalIndex + i - currentIndex;
      items.push(!finite || i >= 0 ? React24.createElement(CarouselSlide, { key, slide: slides[(i + preload * slides.length) % slides.length], offset: i - currentIndex }) : React24.createElement(Placeholder, { key }));
    }
    items.push(React24.createElement(CarouselSlide, { key: globalIndex, slide: slides[currentIndex], offset: 0 }));
    for (let i = currentIndex + 1; i <= currentIndex + preload; i += 1) {
      const key = globalIndex + i - currentIndex;
      items.push(!finite || i <= slides.length - 1 ? React24.createElement(CarouselSlide, { key, slide: slides[i % slides.length], offset: i - currentIndex }) : React24.createElement(Placeholder, { key }));
    }
  }
  return React24.createElement("div", { ref: setCarouselRef, className: clsx(cssClass(cssPrefix2()), items.length > 0 && cssClass(cssPrefix2("with_slides"))), style: {
    [`${cssVar(cssPrefix2("slides_count"))}`]: items.length,
    [`${cssVar(cssPrefix2("spacing_px"))}`]: spacingValue.pixel || 0,
    [`${cssVar(cssPrefix2("spacing_percent"))}`]: spacingValue.percent || 0,
    [`${cssVar(cssPrefix2("padding_px"))}`]: paddingValue.pixel || 0,
    [`${cssVar(cssPrefix2("padding_percent"))}`]: paddingValue.percent || 0
  } }, items);
}
var CarouselModule = createModule(MODULE_CAROUSEL, Carousel);

// node_modules/yet-another-react-lightbox/dist/core/modules/Navigation.js
var React25 = __toESM(require_react(), 1);
function NavigationButton({ label: label2, icon, renderIcon, action, onClick, disabled }) {
  return React25.createElement(IconButton, { label: label2, icon, renderIcon, className: cssClass(`navigation_${action}`), disabled, onClick, ...useLoseFocus(disabled) });
}
function Navigation({ carousel: { finite }, animation, render: { buttonPrev, buttonNext, iconPrev, iconNext } }) {
  var _a;
  const { slides, currentIndex } = useLightboxState();
  const { prev, next, subscribeSensors } = useController();
  const isRTL = useRTL();
  const prevDisabled = slides.length === 0 || finite && currentIndex === 0;
  const nextDisabled = slides.length === 0 || finite && currentIndex === slides.length - 1;
  const throttle = ((_a = animation.navigation) !== null && _a !== void 0 ? _a : animation.swipe) / 2;
  const prevThrottled = useThrottle(prev, throttle);
  const nextThrottled = useThrottle(next, throttle);
  const handleKeyDown = useEventCallback((event) => {
    if (event.key === VK_ARROW_LEFT && !(isRTL ? nextDisabled : prevDisabled)) {
      (isRTL ? nextThrottled : prevThrottled)();
    }
    if (event.key === VK_ARROW_RIGHT && !(isRTL ? prevDisabled : nextDisabled)) {
      (isRTL ? prevThrottled : nextThrottled)();
    }
  });
  React25.useEffect(() => subscribeSensors(EVENT_ON_KEY_DOWN, handleKeyDown), [subscribeSensors, handleKeyDown]);
  return React25.createElement(
    React25.Fragment,
    null,
    buttonPrev ? buttonPrev() : React25.createElement(NavigationButton, { label: "Previous", action: ACTION_PREV, icon: PreviousIcon, renderIcon: iconPrev, disabled: prevDisabled, onClick: prev }),
    buttonNext ? buttonNext() : React25.createElement(NavigationButton, { label: "Next", action: ACTION_NEXT, icon: NextIcon, renderIcon: iconNext, disabled: nextDisabled, onClick: next })
  );
}
var NavigationModule = createModule(MODULE_NAVIGATION, Navigation);

// node_modules/yet-another-react-lightbox/dist/core/modules/NoScroll.js
var React26 = __toESM(require_react(), 1);
var noScroll = cssClass(CLASS_NO_SCROLL);
var noScrollPadding = cssClass(CLASS_NO_SCROLL_PADDING);
function isHTMLElement(element) {
  return "style" in element;
}
function padScrollbar(element, padding, rtl) {
  const styles = window.getComputedStyle(element);
  const property = rtl ? "padding-left" : "padding-right";
  const computedValue = rtl ? styles.paddingLeft : styles.paddingRight;
  const originalValue = element.style.getPropertyValue(property);
  element.style.setProperty(property, `${(parseInt(computedValue, 10) || 0) + padding}px`);
  return () => {
    if (originalValue) {
      element.style.setProperty(property, originalValue);
    } else {
      element.style.removeProperty(property);
    }
  };
}
function NoScroll({ children }) {
  const rtl = useRTL();
  useLayoutEffect2(() => {
    const cleanup2 = [];
    const { body, documentElement } = document;
    const scrollbar = Math.round(window.innerWidth - documentElement.clientWidth);
    if (scrollbar > 0) {
      cleanup2.push(padScrollbar(body, scrollbar, rtl));
      const elements = body.getElementsByTagName("*");
      for (let i = 0; i < elements.length; i += 1) {
        const element = elements[i];
        if (isHTMLElement(element) && window.getComputedStyle(element).getPropertyValue("position") === "fixed" && !element.classList.contains(noScrollPadding)) {
          cleanup2.push(padScrollbar(element, scrollbar, rtl));
        }
      }
    }
    body.classList.add(noScroll);
    return () => {
      body.classList.remove(noScroll);
      cleanup2.forEach((clean) => clean());
    };
  }, [rtl]);
  return React26.createElement(React26.Fragment, null, children);
}
var NoScrollModule = createModule(MODULE_NO_SCROLL, NoScroll);

// node_modules/yet-another-react-lightbox/dist/core/modules/Portal.js
var React27 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/yet-another-react-lightbox/dist/props.js
var LightboxDefaultProps = {
  open: false,
  close: () => {
  },
  index: 0,
  slides: [],
  render: {},
  plugins: [],
  toolbar: { buttons: [ACTION_CLOSE] },
  labels: {},
  animation: {
    fade: 250,
    swipe: 500,
    easing: {
      fade: "ease",
      swipe: "ease-out",
      navigation: "ease-in-out"
    }
  },
  carousel: {
    finite: false,
    preload: 2,
    padding: "16px",
    spacing: "30%",
    imageFit: IMAGE_FIT_CONTAIN
  },
  controller: {
    ref: null,
    focus: true,
    aria: false,
    touchAction: "none",
    closeOnBackdropClick: false
  },
  portal: {},
  on: {},
  styles: {},
  className: ""
};

// node_modules/yet-another-react-lightbox/dist/core/modules/Portal.js
function cssPrefix3(value) {
  return composePrefix(MODULE_PORTAL, value);
}
function setAttribute(element, attribute, value) {
  const previousValue = element.getAttribute(attribute);
  element.setAttribute(attribute, value);
  return () => {
    if (previousValue) {
      element.setAttribute(attribute, previousValue);
    } else {
      element.removeAttribute(attribute);
    }
  };
}
function Portal({ children, animation, styles, className, on, portal, close }) {
  const [mounted, setMounted] = React27.useState(false);
  const [visible, setVisible] = React27.useState(false);
  const cleanup2 = React27.useRef([]);
  const { setTimeout } = useTimeouts();
  const { subscribe } = useEvents();
  const reduceMotion = useMotionPreference();
  const animationDuration = !reduceMotion ? animation.fade : 0;
  React27.useEffect(() => {
    setMounted(true);
    return () => {
      setMounted(false);
      setVisible(false);
    };
  }, []);
  const handleClose = useEventCallback(() => {
    var _a;
    setVisible(false);
    (_a = on.exiting) === null || _a === void 0 ? void 0 : _a.call(on);
    setTimeout(() => {
      var _a2;
      (_a2 = on.exited) === null || _a2 === void 0 ? void 0 : _a2.call(on);
      close();
    }, animationDuration);
  });
  React27.useEffect(() => subscribe(ACTION_CLOSE, handleClose), [subscribe, handleClose]);
  const handleEnter = useEventCallback((node) => {
    var _a, _b, _c;
    node.scrollTop;
    setVisible(true);
    (_a = on.entering) === null || _a === void 0 ? void 0 : _a.call(on);
    const elements = (_c = (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.children) !== null && _c !== void 0 ? _c : [];
    for (let i = 0; i < elements.length; i += 1) {
      const element = elements[i];
      if (["TEMPLATE", "SCRIPT", "STYLE"].indexOf(element.tagName) === -1 && element !== node) {
        cleanup2.current.push(setAttribute(element, "inert", "true"));
        cleanup2.current.push(setAttribute(element, "aria-hidden", "true"));
      }
    }
    setTimeout(() => {
      var _a2;
      (_a2 = on.entered) === null || _a2 === void 0 ? void 0 : _a2.call(on);
    }, animationDuration);
  });
  const handleExit = useEventCallback(() => {
    cleanup2.current.forEach((clean) => clean());
    cleanup2.current = [];
  });
  const handleRef = React27.useCallback((node) => {
    if (node) {
      handleEnter(node);
    } else {
      handleExit();
    }
  }, [handleEnter, handleExit]);
  return mounted ? ReactDOM.createPortal(React27.createElement("div", { ref: handleRef, className: clsx(className, cssClass("root"), cssClass(cssPrefix3()), cssClass(CLASS_NO_SCROLL_PADDING), visible && cssClass(cssPrefix3("open"))), role: "presentation", "aria-live": "polite", style: {
    ...animation.fade !== LightboxDefaultProps.animation.fade ? { [cssVar("fade_animation_duration")]: `${animationDuration}ms` } : null,
    ...animation.easing.fade !== LightboxDefaultProps.animation.easing.fade ? { [cssVar("fade_animation_timing_function")]: animation.easing.fade } : null,
    ...styles.root
  } }, children), portal.root || document.body) : null;
}
var PortalModule = createModule(MODULE_PORTAL, Portal);

// node_modules/yet-another-react-lightbox/dist/core/modules/Root.js
var React28 = __toESM(require_react(), 1);
function Root({ children }) {
  return React28.createElement(React28.Fragment, null, children);
}
var RootModule = createModule(MODULE_ROOT, Root);

// node_modules/yet-another-react-lightbox/dist/core/modules/Toolbar.js
var React29 = __toESM(require_react(), 1);
function cssPrefix4(value) {
  return composePrefix(MODULE_TOOLBAR, value);
}
function Toolbar({ toolbar: { buttons }, render: { buttonClose, iconClose } }) {
  const { close, setToolbarWidth } = useController();
  const { setContainerRef, containerRect } = useContainerRect();
  useLayoutEffect2(() => {
    setToolbarWidth(containerRect === null || containerRect === void 0 ? void 0 : containerRect.width);
  }, [setToolbarWidth, containerRect === null || containerRect === void 0 ? void 0 : containerRect.width]);
  const renderCloseButton = () => {
    if (buttonClose)
      return buttonClose();
    return React29.createElement(IconButton, { key: ACTION_CLOSE, label: "Close", icon: CloseIcon, renderIcon: iconClose, onClick: close });
  };
  return React29.createElement("div", { ref: setContainerRef, className: cssClass(cssPrefix4()) }, buttons === null || buttons === void 0 ? void 0 : buttons.map((button) => button === ACTION_CLOSE ? renderCloseButton() : button));
}
var ToolbarModule = createModule(MODULE_TOOLBAR, Toolbar);

export {
  MODULE_CONTROLLER,
  PLUGIN_COUNTER,
  PLUGIN_FULLSCREEN,
  PLUGIN_THUMBNAILS,
  CLASS_FULLSIZE,
  LightboxDefaultProps,
  clsx,
  cssClass,
  makeUseContext,
  addToolbarButton,
  createModule,
  createNode,
  withPlugins,
  useLayoutEffect2 as useLayoutEffect,
  TimeoutsProvider,
  useEventCallback,
  EventsProvider,
  useLightboxProps,
  LightboxPropsProvider,
  useLightboxState,
  LightboxStateProvider,
  ControllerModule,
  IconButton,
  createIcon,
  CarouselModule,
  NavigationModule,
  NoScrollModule,
  PortalModule,
  RootModule,
  ToolbarModule
};
//# sourceMappingURL=chunk-OBOZWRTA.js.map
